{"version":3,"sources":["src/jquery.i18n.emitter.js"],"names":["$","MessageParserEmitter","language","i18n","languages","String","locale","prototype","constructor","emit","node","replacements","ret","subnodes","operation","messageParserEmitter","map","slice","n","toLowerCase","Error","concat","nodes","result","each","i","replace","index","parseInt","length","plural","count","parseFloat","convertNumber","forms","convertPlural","gender","grammar","form","word","convertGrammar","extend","parser","emitter","jQuery"],"mappings":"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","file":"jquery.i18n.emitter.b4ab222f.map","sourceRoot":"..","sourcesContent":["/*!\n * jQuery Internationalization library\n *\n * Copyright (C) 2011-2013 Santhosh Thottingal, Neil Kandalgaonkar\n *\n * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do\n * anything special to choose one license or the other and you don't have to\n * notify anyone which license you are using. You are free to use\n * UniversalLanguageSelector in commercial projects as long as the copyright\n * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.\n *\n * @licence GNU General Public Licence 2.0 or later\n * @licence MIT License\n */\n\n( function ( $ ) {\n\t'use strict';\n\n\tvar MessageParserEmitter = function () {\n\t\tthis.language = $.i18n.languages[ String.locale ] || $.i18n.languages[ 'default' ];\n\t};\n\n\tMessageParserEmitter.prototype = {\n\t\tconstructor: MessageParserEmitter,\n\n\t\t/**\n\t\t * (We put this method definition here, and not in prototype, to make\n\t\t * sure it's not overwritten by any magic.) Walk entire node structure,\n\t\t * applying replacements and template functions when appropriate\n\t\t *\n\t\t * @param {Mixed} node abstract syntax tree (top node or subnode)\n\t\t * @param {Array} replacements for $1, $2, ... $n\n\t\t * @return {Mixed} single-string node or array of nodes suitable for\n\t\t *  jQuery appending.\n\t\t */\n\t\temit: function ( node, replacements ) {\n\t\t\tvar ret, subnodes, operation,\n\t\t\t\tmessageParserEmitter = this;\n\n\t\t\tswitch ( typeof node ) {\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'number':\n\t\t\t\t\tret = node;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t// node is an array of nodes\n\t\t\t\t\tsubnodes = $.map( node.slice( 1 ), function ( n ) {\n\t\t\t\t\t\treturn messageParserEmitter.emit( n, replacements );\n\t\t\t\t\t} );\n\n\t\t\t\t\toperation = node[ 0 ].toLowerCase();\n\n\t\t\t\t\tif ( typeof messageParserEmitter[ operation ] === 'function' ) {\n\t\t\t\t\t\tret = messageParserEmitter[ operation ]( subnodes, replacements );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error( 'unknown operation \"' + operation + '\"' );\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'undefined':\n\t\t\t\t// Parsing the empty string (as an entire expression, or as a\n\t\t\t\t// paramExpression in a template) results in undefined\n\t\t\t\t// Perhaps a more clever parser can detect this, and return the\n\t\t\t\t// empty string? Or is that useful information?\n\t\t\t\t// The logical thing is probably to return the empty string here\n\t\t\t\t// when we encounter undefined.\n\t\t\t\t\tret = '';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unexpected type in AST: ' + typeof node );\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Parsing has been applied depth-first we can assume that all nodes\n\t\t * here are single nodes Must return a single node to parents -- a\n\t\t * jQuery with synthetic span However, unwrap any other synthetic spans\n\t\t * in our children and pass them upwards\n\t\t *\n\t\t * @param {Array} nodes Mixed, some single nodes, some arrays of nodes.\n\t\t * @return {string}\n\t\t */\n\t\tconcat: function ( nodes ) {\n\t\t\tvar result = '';\n\n\t\t\t$.each( nodes, function ( i, node ) {\n\t\t\t\t// strings, integers, anything else\n\t\t\t\tresult += node;\n\t\t\t} );\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Return escaped replacement of correct index, or string if\n\t\t * unavailable. Note that we expect the parsed parameter to be\n\t\t * zero-based. i.e. $1 should have become [ 0 ]. if the specified\n\t\t * parameter is not found return the same string (e.g. \"$99\" ->\n\t\t * parameter 98 -> not found -> return \"$99\" ) TODO throw error if\n\t\t * nodes.length > 1 ?\n\t\t *\n\t\t * @param {Array} nodes One element, integer, n >= 0\n\t\t * @param {Array} replacements for $1, $2, ... $n\n\t\t * @return {string} replacement\n\t\t */\n\t\treplace: function ( nodes, replacements ) {\n\t\t\tvar index = parseInt( nodes[ 0 ], 10 );\n\n\t\t\tif ( index < replacements.length ) {\n\t\t\t\t// replacement is not a string, don't touch!\n\t\t\t\treturn replacements[ index ];\n\t\t\t} else {\n\t\t\t\t// index not found, fallback to displaying variable\n\t\t\t\treturn '$' + ( index + 1 );\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Transform parsed structure into pluralization n.b. The first node may\n\t\t * be a non-integer (for instance, a string representing an Arabic\n\t\t * number). So convert it back with the current language's\n\t\t * convertNumber.\n\t\t *\n\t\t * @param {Array} nodes List [ {String|Number}, {String}, {String} ... ]\n\t\t * @return {string} selected pluralized form according to current\n\t\t *  language.\n\t\t */\n\t\tplural: function ( nodes ) {\n\t\t\tvar count = parseFloat( this.language.convertNumber( nodes[ 0 ], 10 ) ),\n\t\t\t\tforms = nodes.slice( 1 );\n\n\t\t\treturn forms.length ? this.language.convertPlural( count, forms ) : '';\n\t\t},\n\n\t\t/**\n\t\t * Transform parsed structure into gender Usage\n\t\t * {{gender:gender|masculine|feminine|neutral}}.\n\t\t *\n\t\t * @param {Array} nodes List [ {String}, {String}, {String} , {String} ]\n\t\t * @return {string} selected gender form according to current language\n\t\t */\n\t\tgender: function ( nodes ) {\n\t\t\tvar gender = nodes[ 0 ],\n\t\t\t\tforms = nodes.slice( 1 );\n\n\t\t\treturn this.language.gender( gender, forms );\n\t\t},\n\n\t\t/**\n\t\t * Transform parsed structure into grammar conversion. Invoked by\n\t\t * putting {{grammar:form|word}} in a message\n\t\t *\n\t\t * @param {Array} nodes List [{Grammar case eg: genitive}, {String word}]\n\t\t * @return {string} selected grammatical form according to current\n\t\t *  language.\n\t\t */\n\t\tgrammar: function ( nodes ) {\n\t\t\tvar form = nodes[ 0 ],\n\t\t\t\tword = nodes[ 1 ];\n\n\t\t\treturn word && form && this.language.convertGrammar( word, form );\n\t\t}\n\t};\n\n\t$.extend( $.i18n.parser.emitter, new MessageParserEmitter() );\n}( jQuery ) );\n"]}